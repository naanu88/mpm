<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dynamic Math Problem Generator</title>
  <style>
    :root {
      --bg: #0f172a; --card: #111827; --text: #e5e7eb; --muted: #9ca3af;
      --accent: #22c55e; --accent2: #60a5fa; --danger: #ef4444; --warning: #f59e0b;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; line-height: 1.5; }
    header { padding: 24px 16px; text-align: center; border-bottom: 1px solid #1f2937;
      background: linear-gradient(180deg, #0b1222, var(--bg)); }
    header h1 { margin: 0; font-size: 1.8rem; letter-spacing: .3px; }
    header p { margin: 6px 0 0; color: var(--muted); }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px 16px;
      display: grid; grid-template-columns: 1fr 2fr; gap: 16px; }
    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 12px; padding: 16px; }
    .card h2 { margin: 0 0 12px; font-size: 1.2rem; }
    .controls .row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 12px; }
    label { font-size: .9rem; color: var(--muted); display: block; margin-bottom: 6px; }
    select, input[type="text"], input[type="number"] {
      width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #374151;
      background: #0b1222; color: var(--text);
    }
    .btns { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 8px; }
    button { background: #1f2937; color: var(--text); border: 1px solid #374151; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
    button.primary { background: var(--accent); border-color: #16a34a; color: #082f1f; font-weight: 600; }
    button.secondary { background: var(--accent2); border-color: #3b82f6; color: #0b213f; font-weight: 600; }
    button.warn { background: var(--warning); border-color: #d97706; color: #3a2500; font-weight: 600; }
    .problem { font-size: 1.08rem; white-space: pre-wrap; }
    .meta { color: var(--muted); font-size: .9rem; margin-bottom: 8px; }
    .answer-area { display: grid; grid-template-columns: 2fr 1fr auto; gap: 10px; align-items: center; margin-top: 12px; }
    .badge { display: inline-block; font-size: .8rem; padding: 4px 8px; border-radius: 999px; border: 1px solid #374151; background: #0b1222; color: var(--muted); margin-right: 6px; }
    .ok { color: #10b981; } .no { color: #ef4444; }
    .solution { background: #0b1222; border: 1px dashed #374151; border-radius: 8px; padding: 12px; margin-top: 12px; font-size: .95rem; }
    .footer { text-align: center; color: var(--muted); font-size: .85rem; padding: 18px 0 26px; }
    code.seed { background: #0b1222; border: 1px solid #374151; padding: 2px 6px; border-radius: 6px; }
    .split { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .count { font-size: .9rem; color: var(--muted); }
    .small { font-size: .8rem; color: var(--muted); }
    @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <header>
    <h1>Dynamic Math Problem Generator</h1>
    <p>100+ templates per branch, five difficulties, three styles, seeds for reproducibility.</p>
  </header>

  <div class="container">
    <div class="card controls">
      <h2>Controls</h2>

      <div class="row">
        <div>
          <label for="branch">Branch of maths</label>
          <select id="branch"></select>
        </div>
        <div>
          <label for="difficulty">Difficulty</label>
          <select id="difficulty">
            <option>easy</option>
            <option>medium</option>
            <option>hard</option>
            <option>harder</option>
            <option>EXTREME</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="style">Problem style</label>
          <select id="style">
            <option>Normal</option>
            <option>Word Problem</option>
            <option>Problem Solving</option>
          </select>
        </div>
        <div>
          <label for="seed">Seed (optional, reproducible)</label>
          <input id="seed" type="text" placeholder="e.g., MATH-2025-42" />
        </div>
      </div>

      <div class="btns">
        <button id="generate" class="primary">Generate problem</button>
        <button id="randomize" class="secondary">Randomize options</button>
        <button id="copyLink" class="warn">Copy shareable link</button>
        <button id="newSeed">New seed</button>
      </div>
      <div class="count" id="comboCount"></div>
      <div class="small" id="branchCounts"></div>
    </div>

    <div class="card">
      <h2>Problem</h2>
      <div class="meta" id="meta"></div>
      <div class="problem" id="problem">Choose settings and click “Generate problem”.</div>

      <div class="answer-area">
        <input id="answer" type="text" placeholder="Enter your answer (number, fraction, etc.)" />
        <button id="check" class="primary">Check answer</button>
        <span id="feedback" class="badge"></span>
      </div>

      <div class="split">
        <button id="showSolution">Show solution</button>
        <button id="newProblem">New problem (same settings)</button>
        <span>Seed: <code class="seed" id="seedDisplay">—</code></span>
      </div>

      <div class="solution" id="solution" style="display:none;"></div>
    </div>
  </div>

  <div class="footer">
    Single-file app for GitHub Pages. Scalable templates. Infinite variation.
  </div>

<script>
/* ===== Core state ===== */
const state = { branch: null, difficulty: 'easy', style: 'Normal', seed: null, rng: null, current: null };
const difficulties = ['easy','medium','hard','harder','EXTREME'];
const styles = ['Normal','Word Problem','Problem Solving'];

/* ===== Seeded RNG ===== */
function hashSeed(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }
function makeRNG(seed){ let a=(seed^0x9E3779B9)>>>0,b=(seed^0x243F6A88)>>>0,c=(seed^0xB7E15162)>>>0,d=(seed^0xC6EF3720)>>>0;
  return function(){ a=(a^(a<<11))>>>0; b=(b^(b>>>7))>>>0; c=(c^(c<<17))>>>0; d=(d^(d>>>13))>>>0; const t=(a+b+c+d)>>>0; return (t/0xFFFFFFFF); }; }
function rndInt(rng,min,max){ return Math.floor(rng()*(max-min+1))+min; }
function choice(rng,arr){ return arr[Math.floor(rng()*arr.length)]; }
function shuffle(rng,arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(rng()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function approxEqual(a,b,eps=1e-6){ return Math.abs(a-b)<eps; }
function gcd(a,b){ return b ? gcd(b,a%b) : a; }

/* ===== Difficulty config ===== */
const diffConf = {
  easy:   { range: 10, steps: 2, terms: 2, decimals: false },
  medium: { range: 25, steps: 3, terms: 3, decimals: false },
  hard:   { range: 50, steps: 4, terms: 3, decimals: true },
  harder: { range: 100, steps: 5, terms: 4, decimals: true },
  EXTREME:{ range: 200, steps: 6, terms: 5, decimals: true }
};

/* ===== Style decorator ===== */
function styleWrap(style, text, context) {
  if (style === 'Normal') return text;
  if (style === 'Word Problem') {
    const names = ['Ava','Liam','Mia','Noah','Zoe','Ethan','Isla','Leo','Chloe','Jack','Aria','Finn','Nate','Ruby','Kai'];
    const places = ['a market','a school','a lab','a track','a cafe','a farm','a library','a workshop','a stadium','a studio'];
    const who = context?.name || names[Math.floor(state.rng()*names.length)];
    const where = context?.place || places[Math.floor(state.rng()*places.length)];
    return `${who} is at ${where}. ${text}`;
  }
  return `${text}\n\nExplain your reasoning and justify each step before giving the final answer.`;
}

/* ===== Answer parsing ===== */
function parseAnswer(str){
  str=String(str||'').trim();
  if(!str) return null;
  if(str.includes('/')){
    const [n,d]=str.split('/').map(s=>s.trim());
    const numer=Number(n),denom=Number(d);
    if(Number.isFinite(numer)&&Number.isFinite(denom)&&denom!==0) return numer/denom;
  }
  if(str.endsWith('%')){ const p=Number(str.slice(0,-1)); if(Number.isFinite(p)) return p/100; }
  const val=Number(str);
  if(Number.isFinite(val)) return val;
  return null;
}

/* ===== Branch list ===== */
const branches = [
  'Arithmetic','Algebra','Ratios & Proportions','Rates','Percentages','Geometry','Probability',
  'Statistics','Number Theory','Sequences & Series','Functions','Linear Equations','Systems of Equations',
  'Exponents & Radicals'
];

/* ===== Template builder helpers ===== */
function variantPhrasings(base, variants){
  return variants.map(v => ({ ...base, phrase: v }));
}
function buildFamilyVariants(familyFn, variantCount){
  // Create N variant wrappers around a core family function
  const arr = [];
  for(let i=0;i<variantCount;i++){
    arr.push((rng,d,style) => familyFn(rng,d,style,i));
  }
  return arr;
}
function bounded(val, min, max){ return Math.max(min, Math.min(max, val)); }

/* ===== Families per branch (each returns {prompt, answer, steps}) =====
   We will compose >= 100 templates per branch by:
   - 12–16 core families
   - 8–12 variants per family (wording, structure twists, parameterization)
*/

/* ---------- Arithmetic ---------- */
const ArithmeticFamilies = {
  addBasic: (rng,d,style,variant)=>{
    const cfg=diffConf[d]; const a=rndInt(rng,1,cfg.range), b=rndInt(rng,1,cfg.range);
    const phrasings=[
      `Compute ${a} + ${b}`, `Find the sum of ${a} and ${b}`, `Add ${a} to ${b}`, `What is ${a} plus ${b}?`
    ];
    const prompt = styleWrap(style, choice(rng, phrasings), {});
    const steps=[`Add ${a} and ${b}.`,`Result = ${a+b}.`];
    return { prompt, answer:a+b, steps };
  },
  subtractBasic: (rng,d,style,variant)=>{
    const cfg=diffConf[d]; const a=rndInt(rng,2,cfg.range*2), b=rndInt(rng,1,cfg.range);
    const prompt = styleWrap(style, variant%2 ? `Compute ${a} - ${b}` : `Subtract ${b} from ${a}`, {});
    const steps=[`Subtract ${b} from ${a}.`,`Result = ${a-b}.`];
    return { prompt, answer:a-b, steps };
  },
  multiplyTables: (rng,d,style,variant)=>{
    const a=rndInt(rng,2,12), b=rndInt(rng,2,12);
    const prompt=styleWrap(style, `Compute ${a} × ${b}`, {});
    const steps=[`Multiply ${a} by ${b}.`,`Result = ${a*b}.`];
    return { prompt, answer:a*b, steps };
  },
  divideQuotRem: (rng,d,style,variant)=>{
    const a=rndInt(rng,20,240), b=rndInt(rng,2,12);
    const q=Math.floor(a/b), r=a%b;
    const prompt=styleWrap(style, `Divide ${a} by ${b}. Give the remainder.`, {});
    const steps=[`${a} ÷ ${b} = ${q} remainder ${r}.`];
    // Answer is remainder only for auto-check simplicity
    return { prompt, answer:r, steps };
  },
  orderOfOps: (rng,d,style,variant)=>{
    const cfg=diffConf[d];
    const a=rndInt(rng,1,cfg.range), b=rndInt(rng,1,cfg.range), c=rndInt(rng,1,cfg.range);
    const prompt=styleWrap(style, `Compute ${a} + ${b} × ${c}`, {});
    const ans=a + b*c;
    const steps=[`Apply order: multiply first: ${b}×${c}=${b*c}.`,`Then add ${a} + ${b*c} = ${ans}.`];
    return { prompt, answer:ans, steps };
  },
  fractionAdd: (rng,d,style,variant)=>{
    const a=rndInt(rng,1,9), b=rndInt(rng,2,9), c=rndInt(rng,1,9), dnm=rndInt(rng,2,9);
    const numer = a*dnm + c*b, denom = b*dnm; const g=gcd(numer,denom); const simp = `${numer/g}/${denom/g}`;
    const prompt=styleWrap(style, `Compute ${a}/${b} + ${c}/${dnm}. Give the result as a simplified fraction.`, {});
    const steps=[`LCD = ${b}×${dnm} = ${b*dnm}.`,`Add numerators: ${a*dnm}+${c*b}=${numer}.`,`Simplify → ${simp}.`];
    const ans = (numer/denom);
    return { prompt, answer:ans, steps };
  },
  decimalAdd: (rng,d,style,variant)=>{
    const x=(rndInt(rng,10,999))/10, y=(rndInt(rng,10,999))/10;
    const prompt=styleWrap(style, `Compute ${x.toFixed(1)} + ${y.toFixed(1)}.`, {});
    const ans=Number((x+y).toFixed(2));
    const steps=[`Add decimals: ${x.toFixed(1)} + ${y.toFixed(1)} = ${(x+y).toFixed(2)}.`];
    return { prompt, answer:ans, steps };
  },
  rounding: (rng,d,style,variant)=>{
    const x=(rndInt(rng,100,9999))/10; const places=variant%3===0?0:(variant%3===1?1:2);
    const prompt=styleWrap(style, `Round ${x.toFixed(3)} to ${places} decimal place(s).`, {});
    const ans=Number(x.toFixed(places));
    const steps=[`Rounding rules → ${ans}.`];
    return { prompt, answer:ans, steps };
  },
  mixedOpsParen: (rng,d,style,variant)=>{
    const cfg=diffConf[d];
    const a=rndInt(rng,1,cfg.range), b=rndInt(rng,1,cfg.range), c=rndInt(rng,1,cfg.range);
    const prompt=styleWrap(style, `Compute (${a} + ${b}) × ${c}`, {});
    const ans=(a+b)*c;
    const steps=[`Compute inside parentheses: ${a}+${b}=${a+b}.`,`Multiply by ${c}: ${(a+b)}×${c}=${ans}.`];
    return { prompt, answer:ans, steps };
  },
  percentOf: (rng,d,style,variant)=>{
    const base=rndInt(rng,50,500), pct=rndInt(rng,5,60);
    const prompt=styleWrap(style, `Find ${pct}% of ${base}.`, {});
    const ans=Number((base*pct/100).toFixed(2));
    const steps=[`${pct}% of ${base} = ${base} × ${pct}/100 = ${ans}.`];
    return { prompt, answer:ans, steps };
  }
};
// Expand to >= 100 templates by variants
const ArithmeticTemplates = [].concat(
  buildFamilyVariants(ArithmeticFamilies.addBasic, 12),
  buildFamilyVariants(ArithmeticFamilies.subtractBasic, 12),
  buildFamilyVariants(ArithmeticFamilies.multiplyTables, 10),
  buildFamilyVariants(ArithmeticFamilies.divideQuotRem, 10),
  buildFamilyVariants(ArithmeticFamilies.orderOfOps, 10),
  buildFamilyVariants(ArithmeticFamilies.fractionAdd, 12),
  buildFamilyVariants(ArithmeticFamilies.decimalAdd, 8),
  buildFamilyVariants(ArithmeticFamilies.rounding, 8),
  buildFamilyVariants(ArithmeticFamilies.mixedOpsParen, 10),
  buildFamilyVariants(ArithmeticFamilies.percentOf, 10)
); // total 102

/* ---------- Algebra ---------- */
const AlgebraFamilies = {
  linearSolve: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const A=rndInt(rng,1,cfg.range), B=rndInt(rng,-cfg.range,cfg.range), C=rndInt(rng,-cfg.range,cfg.range);
    const x=(C-B)/A;
    const prompt=styleWrap(style, `Solve ${A}x + ${B} = ${C} for x.`, {});
    const steps=[`x = (C-B)/A = (${C}-${B})/${A} = ${x}.`];
    return { prompt, answer:x, steps };
  },
  expandBinomial: (rng,d,style,v)=>{
    const p=rndInt(rng,1,12), q=rndInt(rng,-12,12);
    const prompt=styleWrap(style, `Expand (x + ${p})(x + ${q}). Give the coefficient of x.`, {});
    const ans=p+q; const steps=[`(x+p)(x+q) = x^2 + (${p}+${q})x + ${p*q}.`];
    return { prompt, answer:ans, steps };
  },
  factorQuadratic: (rng,d,style,v)=>{
    const r=rndInt(rng,1,12), s=rndInt(rng,1,12), sum=r+s, prod=r*s;
    const prompt=styleWrap(style, `Factor x^2 + ${sum}x + ${prod}. Provide the smaller factor.`, {});
    const steps=[`Numbers adding ${sum} and multiplying ${prod}: ${r} & ${s}.`];
    return { prompt, answer:Math.min(r,s), steps };
  },
  simplifyExpr: (rng,d,style,v)=>{
    const a=rndInt(rng,1,9), b=rndInt(rng,1,9), c=rndInt(rng,1,9);
    const prompt=styleWrap(style, `Simplify ${a}x + ${b}x - ${c}x. Give the coefficient of x.`, {});
    const ans=a+b-c; const steps=[`Combine like terms: ${a}+${b}-${c} = ${ans}.`];
    return { prompt, answer:ans, steps };
  },
  inequalitySolve: (rng,d,style,v)=>{
    const A=rndInt(rng,1,12), B=rndInt(rng,-20,20), C=rndInt(rng,-20,20);
    const prompt=styleWrap(style, `Solve ${A}x + ${B} > ${C}. Give the boundary value of x.`, {});
    const boundary=(C-B)/A; const steps=[`x > (C-B)/A = (${C}-${B})/${A} = ${boundary}.`];
    return { prompt, answer:boundary, steps };
  },
  exponentRules: (rng,d,style,v)=>{
    const a=rndInt(rng,2,6), m=rndInt(rng,1,5), n=rndInt(rng,1,5);
    const prompt=styleWrap(style, `Simplify ${a}^${m} × ${a}^${n}. Give the exponent.`, {});
    const steps=[`Add exponents: ${m}+${n}=${m+n}.`]; return { prompt, answer:m+n, steps };
  },
  radicalsSimplify: (rng,d,style,v)=>{
    const k=rndInt(rng,2,12), x=k*k*rndInt(rng,2,12);
    const prompt=styleWrap(style, `Simplify √${x}. Give the coefficient outside the radical.`, {});
    const coeff=k; const steps=[`√(${k*k}·m) = ${k}√m → coefficient ${k}.`];
    return { prompt, answer:coeff, steps };
  },
  substitutionEval: (rng,d,style,v)=>{
    const a=rndInt(rng,1,10), b=rndInt(rng,-10,10), x=rndInt(rng,1,10);
    const fx=a*x+b; const prompt=styleWrap(style, `Let f(x)=${a}x+${b}. Compute f(${x}).`, {});
    const steps=[`f(${x})=${a}×${x}+${b}=${fx}.`]; return { prompt, answer:fx, steps };
  },
  quadraticVertex: (rng,d,style,v)=>{
    const a=rndInt(rng,1,5), b=rndInt(rng,-10,10), c=rndInt(rng,-10,10);
    const h=-b/(2*a); const prompt=styleWrap(style, `For y=${a}x^2+${b}x+${c}, give the x-coordinate of the vertex.`, {});
    const steps=[`h=-b/(2a) = -(${b})/(2·${a}) = ${h}.`];
    return { prompt, answer:h, steps };
  },
  factorOutGCF: (rng,d,style,v)=>{
    const a=rndInt(rng,6,60), b=rndInt(rng,6,60), g=gcd(a,b);
    const prompt=styleWrap(style, `Find gcd of ${a}x and ${b}x.`, {});
    const steps=[`gcd(${a},${b})=${g}.`]; return { prompt, answer:g, steps };
  }
};
const AlgebraTemplates = [].concat(
  buildFamilyVariants(AlgebraFamilies.linearSolve, 12),
  buildFamilyVariants(AlgebraFamilies.expandBinomial, 10),
  buildFamilyVariants(AlgebraFamilies.factorQuadratic, 10),
  buildFamilyVariants(AlgebraFamilies.simplifyExpr, 10),
  buildFamilyVariants(AlgebraFamilies.inequalitySolve, 10),
  buildFamilyVariants(AlgebraFamilies.exponentRules, 10),
  buildFamilyVariants(AlgebraFamilies.radicalsSimplify, 8),
  buildFamilyVariants(AlgebraFamilies.substitutionEval, 10),
  buildFamilyVariants(AlgebraFamilies.quadraticVertex, 5),
  buildFamilyVariants(AlgebraFamilies.factorOutGCF, 10)
); // 95 → add a small filler to exceed 100
AlgebraTemplates.push(...buildFamilyVariants(AlgebraFamilies.linearSolve, 8)); // 103

/* ---------- Ratios & Proportions ---------- */
const RatioFamilies = {
  scaleRatio: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const a=rndInt(rng,2,cfg.range), b=rndInt(rng,2,cfg.range), k=rndInt(rng,2,9);
    const prompt=styleWrap(style, `Scale the ratio ${a}:${b} by ${k}. Provide the first term.`, {});
    const steps=[`Result: ${a*k}:${b*k} → first term ${a*k}.`]; return { prompt, answer:a*k, steps };
  },
  simplifyRatio: (rng,d,style,v)=>{
    const a=rndInt(rng,6,120), b=rndInt(rng,6,120), g=gcd(a,b);
    const prompt=styleWrap(style, `Simplify the ratio ${a}:${b}. Give the first simplified term.`, {});
    const steps=[`Divide by gcd ${g} → ${a/g}:${b/g}.`]; return { prompt, answer:a/g, steps };
  },
  proportionSolve: (rng,d,style,v)=>{
    const p=rndInt(rng,2,20), q=rndInt(rng,2,20), r=rndInt(rng,2,20);
    const x = (q*r)/p;
    const prompt=styleWrap(style, `Solve ${p}:${q} = r:${r}. Find r such that equality holds (missing term).`, {});
    const steps=[`p:q = ? : r ⇒ ? = (q·r)/p = ${x}.`]; return { prompt, answer:x, steps };
  },
  unitRate: (rng,d,style,v)=>{
    const a=rndInt(rng,2,200), b=rndInt(rng,2,50); const prompt=styleWrap(style, `Find the unit rate of ${a} items in ${b} hours.`, {});
    const ans=Number((a/b).toFixed(4)); const steps=[`Unit rate = ${a}/${b} = ${ans}.`]; return { prompt, answer:ans, steps };
  },
  recipeScale: (rng,d,style,v)=>{
    const sugar=rndInt(rng,50,300), flour=rndInt(rng,100,500), scale=rndInt(rng,2,5);
    const prompt=styleWrap(style, `Scale a recipe: sugar ${sugar}g, flour ${flour}g by ×${scale}. Provide scaled sugar.`, {});
    const steps=[`Sugar → ${sugar*scale}g.`]; return { prompt, answer:sugar*scale, steps };
  }
};
const RatioTemplates = [].concat(
  buildFamilyVariants(RatioFamilies.scaleRatio, 25),
  buildFamilyVariants(RatioFamilies.simplifyRatio, 25),
  buildFamilyVariants(RatioFamilies.proportionSolve, 25),
  buildFamilyVariants(RatioFamilies.unitRate, 15),
  buildFamilyVariants(RatioFamilies.recipeScale, 12)
); // 102

/* ---------- Rates ---------- */
const RatesFamilies = {
  avgSpeed: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const dist=rndInt(rng,5,cfg.range*2), time=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5)));
    const speed=dist/time; const prompt=styleWrap(style, `A trip covers ${dist} km in ${time} hours. Average speed (km/h)?`, {});
    const steps=[`Speed = ${dist}/${time} = ${speed.toFixed(4)} km/h.`]; return { prompt, answer:Number(speed.toFixed(4)), steps };
  },
  workRate: (rng,d,style,v)=>{
    const a=rndInt(rng,2,8), b=rndInt(rng,2,8);
    const prompt=styleWrap(style, `Worker A finishes in ${a} h, B in ${b} h together: time?`, {});
    const t = 1/(1/a + 1/b); const steps=[`Combined rate = 1/${a}+1/${b}; time = 1/(sum) = ${t.toFixed(4)} h.`];
    return { prompt, answer:Number(t.toFixed(4)), steps };
  },
  flowRate: (rng,d,style,v)=>{
    const vol=rndInt(rng,50,500), t=rndInt(rng,5,60);
    const prompt=styleWrap(style, `Flow rate: ${vol} L in ${t} min. L/min?`, {});
    const ans=Number((vol/t).toFixed(4)); const steps=[`Rate = ${vol}/${t} = ${ans} L/min.`]; return { prompt, answer:ans, steps };
  },
  speedDistanceTime: (rng,d,style,v)=>{
    const s=rndInt(rng,20,120), t=rndInt(rng,1,6);
    const prompt=styleWrap(style, `Given speed ${s} km/h for ${t} h, distance?`, {});
    const ans=s*t; const steps=[`d = s·t = ${s}×${t} = ${ans} km.`]; return { prompt, answer:ans, steps };
  },
  rateConversion: (rng,d,style,v)=>{
    const mph=rndInt(rng,20,80); const prompt=styleWrap(style, `Convert ${mph} mph to km/h (use 1 mi ≈ 1.609 km).`, {});
    const ans=Number((mph*1.609).toFixed(3)); const steps=[`${mph}×1.609 = ${ans}.`]; return { prompt, answer:ans, steps };
  }
};
const RatesTemplates = [].concat(
  buildFamilyVariants(RatesFamilies.avgSpeed, 25),
  buildFamilyVariants(RatesFamilies.workRate, 20),
  buildFamilyVariants(RatesFamilies.flowRate, 20),
  buildFamilyVariants(RatesFamilies.speedDistanceTime, 20),
  buildFamilyVariants(RatesFamilies.rateConversion, 20)
); // 105

/* ---------- Percentages ---------- */
const PercentFamilies = {
  pctIncreaseDecrease: (rng,d,style,v)=>{
    const base=rndInt(rng,50,1000), pct=rndInt(rng,5,60), inc=Boolean(v%2);
    const prompt=styleWrap(style, `${inc?'Increase':'Decrease'} ${base} by ${pct}%. Final value?`, {});
    const ans=Number((base*(1+(inc?1:-1)*pct/100)).toFixed(2));
    const steps=[`Final = ${base} × (1 ${inc?'+':'-'} ${pct}/100) = ${ans}.`]; return { prompt, answer:ans, steps };
  },
  pctOf: (rng,d,style,v)=>{
    const base=rndInt(rng,100,900), pct=rndInt(rng,1,90);
    const prompt=styleWrap(style, `Find ${pct}% of ${base}.`, {});
    const ans=Number((base*pct/100).toFixed(2)); const steps=[`${base}×${pct}/100 = ${ans}.`]; return { prompt, answer:ans, steps };
  },
  reversePct: (rng,d,style,v)=>{
    const final=rndInt(rng,100,900), pct=rndInt(rng,5,60), inc=Boolean(v%2);
    const base = final/(1+(inc?1:-1)*pct/100);
    const prompt=styleWrap(style, `${final} is after a ${inc?'increase':'decrease'} of ${pct}%. Original value?`, {});
    const steps=[`Original = final / (1 ${inc?'+':'-'} p) = ${base.toFixed(4)}.`]; return { prompt, answer:Number(base.toFixed(4)), steps };
  },
  pctChange: (rng,d,style,v)=>{
    const old=rndInt(rng,50,800), nu=rndInt(rng,50,800);
    const prompt=styleWrap(style, `Percent change from ${old} to ${nu}?`, {});
    const ans=Number(((nu-old)/old*100).toFixed(3)); const steps=[`Δ% = (new-old)/old × 100 = ${ans}%.`]; return { prompt, answer:ans/100, steps };
  },
  discountTax: (rng,d,style,v)=>{
    const price=rndInt(rng,50,500), disc=rndInt(rng,5,40), tax=rndInt(rng,5,15);
    const final=price*(1-disc/100)*(1+tax/100);
    const prompt=styleWrap(style, `Price ${price}, discount ${disc}%, tax ${tax}%. Final price?`, {});
    const steps=[`Final = ${price}×(1-${disc}/100)×(1+${tax}/100) = ${final.toFixed(2)}.`];
    return { prompt, answer:Number(final.toFixed(2)), steps };
  }
};
const PercentTemplates = [].concat(
  buildFamilyVariants(PercentFamilies.pctIncreaseDecrease, 25),
  buildFamilyVariants(PercentFamilies.pctOf, 25),
  buildFamilyVariants(PercentFamilies.reversePct, 25),
  buildFamilyVariants(PercentFamilies.pctChange, 15),
  buildFamilyVariants(PercentFamilies.discountTax, 12)
); // 102

/* ---------- Geometry ---------- */
const GeometryFamilies = {
  rectArea: (rng,d,style,v)=>{
    const w=rndInt(rng,2,50), h=rndInt(rng,2,50); const prompt=styleWrap(style, `Rectangle width ${w}, height ${h}. Area?`, {});
    const steps=[`Area = w·h = ${w}×${h} = ${w*h}.`]; return { prompt, answer:w*h, steps };
  },
  triArea: (rng,d,style,v)=>{
    const b=rndInt(rng,2,50), h=rndInt(rng,2,50); const prompt=styleWrap(style, `Triangle base ${b}, height ${h}. Area?`, {});
    const ans=0.5*b*h; const steps=[`A=½·b·h = ${ans}.`]; return { prompt, answer:Number(ans.toFixed(4)), steps };
  },
  circleCirc: (rng,d,style,v)=>{
    const r=rndInt(rng,2,30); const C=2*Math.PI*r;
    const prompt=styleWrap(style, `Circle radius ${r}. Circumference (π≈${Math.PI.toFixed(3)})?`, {});
    const steps=[`C=2πr = ${C.toFixed(4)}.`]; return { prompt, answer:Number(C.toFixed(4)), steps };
  },
  pythag: (rng,d,style,v)=>{
    const a=rndInt(rng,3,50), b=rndInt(rng,4,50); const c=Math.sqrt(a*a+b*b);
    const prompt=styleWrap(style, `Right triangle legs ${a}, ${b}. Hypotenuse?`, {});
    const steps=[`c=√(a²+b²)=${c.toFixed(4)}.`]; return { prompt, answer:Number(c.toFixed(4)), steps };
  },
  polygonIntAngles: (rng,d,style,v)=>{
    const n=rndInt(rng,3,12); const sum=(n-2)*180; const prompt=styleWrap(style, `Sum of interior angles of an ${n}-gon?`, {});
    const steps=[`Sum=(n-2)·180 = ${sum}.`]; return { prompt, answer:sum, steps };
  },
  prismVolume: (rng,d,style,v)=>{
    const l=rndInt(rng,2,20), w=rndInt(rng,2,20), h=rndInt(rng,2,20);
    const prompt=styleWrap(style, `Rectangular prism ${l}×${w}×${h}. Volume?`, {});
    const ans=l*w*h; const steps=[`V=l·w·h=${ans}.`]; return { prompt, answer:ans, steps };
  },
  circleArea: (rng,d,style,v)=>{
    const r=rndInt(rng,2,30); const A=Math.PI*r*r;
    const prompt=styleWrap(style, `Circle radius ${r}. Area (π≈${Math.PI.toFixed(3)})?`, {});
    const steps=[`A=πr²=${A.toFixed(4)}.`]; return { prompt, answer:Number(A.toFixed(4)), steps };
  },
  trapezoidArea: (rng,d,style,v)=>{
    const a=rndInt(rng,2,40), b=rndInt(rng,2,40), h=rndInt(rng,2,40);
    const A=((a+b)/2)*h; const prompt=styleWrap(style, `Trapezoid with bases ${a}, ${b} and height ${h}. Area?`, {});
    const steps=[`A=(a+b)/2·h=${A.toFixed(4)}.`]; return { prompt, answer:Number(A.toFixed(4)), steps };
  },
  surfaceCube: (rng,d,style,v)=>{
    const s=rndInt(rng,2,50); const SA=6*s*s;
    const prompt=styleWrap(style, `Cube side ${s}. Surface area?`, {});
    const steps=[`SA=6s² = ${SA}.`]; return { prompt, answer:SA, steps };
  },
  angleCircleSector: (rng,d,style,v)=>{
    const r=rndInt(rng,3,30), theta=rndInt(rng,15,300);
    const A=(theta/360)*Math.PI*r*r; const prompt=styleWrap(style, `Sector radius ${r}, angle ${theta}°. Area? (π≈${Math.PI.toFixed(3)})`, {});
    const steps=[`A=(θ/360)πr²=${A.toFixed(4)}.`]; return { prompt, answer:Number(A.toFixed(4)), steps };
  }
};
const GeometryTemplates = [].concat(
  buildFamilyVariants(GeometryFamilies.rectArea, 12),
  buildFamilyVariants(GeometryFamilies.triArea, 12),
  buildFamilyVariants(GeometryFamilies.circleCirc, 10),
  buildFamilyVariants(GeometryFamilies.pythag, 10),
  buildFamilyVariants(GeometryFamilies.polygonIntAngles, 10),
  buildFamilyVariants(GeometryFamilies.prismVolume, 12),
  buildFamilyVariants(GeometryFamilies.circleArea, 10),
  buildFamilyVariants(GeometryFamilies.trapezoidArea, 12),
  buildFamilyVariants(GeometryFamilies.surfaceCube, 10),
  buildFamilyVariants(GeometryFamilies.angleCircleSector, 10)
); // 108

/* ---------- Probability ---------- */
const ProbabilityFamilies = {
  drawBalls: (rng,d,style,v)=>{
    const r=rndInt(rng,1,15), b=rndInt(rng,1,15), tot=r+b, p=r/tot;
    const prompt=styleWrap(style, `Bag has ${r} red, ${b} blue. Probability of red?`, {});
    const steps=[`P(red)=${r}/${tot}=${p.toFixed(4)}.`]; return { prompt, answer:Number(p.toFixed(4)), steps };
  },
  coinFlips: (rng,d,style,v)=>{
    const n=rndInt(rng,1,6), k=rndInt(rng,0,n);
    const comb = (n,k)=>{ let r=1; for(let i=1;i<=k;i++){ r=r*(n-(k-i))/i; } return r; };
    const p = comb(n,k)*Math.pow(0.5,n);
    const prompt=styleWrap(style, `Probability of exactly ${k} heads in ${n} fair coin flips?`, {});
    const steps=[`P= C(${n},${k})·(1/2)^${n} = ${p.toFixed(6)}.`]; return { prompt, answer:Number(p.toFixed(6)), steps };
  },
  diceSum: (rng,d,style,v)=>{
    const target=rndInt(rng,2,12), ways=[0,0,1,2,3,4,5,6,5,4,3,2,1][target];
    const p=ways/36; const prompt=styleWrap(style, `Two dice: probability sum=${target}?`, {});
    const steps=[`Ways=${ways}/36 → P=${p.toFixed(6)}.`]; return { prompt, answer:Number(p.toFixed(6)), steps };
  },
  conditional: (rng,d,style,v)=>{
    const a=rndInt(rng,10,90), b=rndInt(rng,10,90), ab=rndInt(rng,0,Math.min(a,b));
    const Pab=ab/100, Pb=b/100, cond=Pab/Pb;
    const prompt=styleWrap(style, `Given P(A)=${(a/100).toFixed(2)}, P(B)=${(b/100).toFixed(2)}, P(A∩B)=${(Pab).toFixed(2)}. Find P(A|B).`, {});
    const steps=[`P(A|B)=P(A∩B)/P(B)=${cond.toFixed(4)}.`]; return { prompt, answer:Number(cond.toFixed(4)), steps };
  },
  expectedValue: (rng,d,style,v)=>{
    const vals=[rndInt(rng,1,10),rndInt(rng,1,10),rndInt(rng,1,10)];
    const psRaw=[rndInt(rng,1,9),rndInt(rng,1,9),rndInt(rng,1,9)];
    const sum=psRaw.reduce((a,b)=>a+b,0); const ps=psRaw.map(x=>x/sum);
    const EV=Number((vals[0]*ps[0]+vals[1]*ps[1]+vals[2]*ps[2]).toFixed(4));
    const prompt=styleWrap(style, `Expected value for outcomes ${vals.join(', ')} with probabilities ${ps.map(p=>p.toFixed(2)).join(', ')}?`, {});
    const steps=[`EV=Σ x_i p_i = ${EV}.`]; return { prompt, answer:EV, steps };
  }
};
const ProbabilityTemplates = [].concat(
  buildFamilyVariants(ProbabilityFamilies.drawBalls, 30),
  buildFamilyVariants(ProbabilityFamilies.coinFlips, 25),
  buildFamilyVariants(ProbabilityFamilies.diceSum, 25),
  buildFamilyVariants(ProbabilityFamilies.conditional, 10),
  buildFamilyVariants(ProbabilityFamilies.expectedValue, 12)
); // 102

/* ---------- Statistics ---------- */
const StatisticsFamilies = {
  mean: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const n=rndInt(rng,4,8+cfg.steps);
    const arr=Array.from({length:n},()=>rndInt(rng,1,cfg.range)); const sum=arr.reduce((a,b)=>a+b,0); const mean=sum/n;
    const prompt=styleWrap(style, `Compute mean of [${arr.join(', ')}].`, {});
    const steps=[`Mean=sum/n=${sum}/${n}=${mean.toFixed(4)}.`]; return { prompt, answer:Number(mean.toFixed(4)), steps };
  },
  median: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const n=rndInt(rng,5,11+cfg.steps);
    const arr=Array.from({length:n},()=>rndInt(rng,1,cfg.range)).sort((a,b)=>a-b);
    const med = n%2? arr[(n-1)/2] : (arr[n/2-1]+arr[n/2])/2;
    const prompt=styleWrap(style, `Compute median of [${arr.join(', ')}].`, {});
    const steps=[`Sorted → median=${med}.`]; return { prompt, answer: (typeof med==='number'? med: Number(med.toFixed(4))), steps };
  },
  mode: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const n=rndInt(rng,6,14); const arr=Array.from({length:n},()=>rndInt(rng,1,cfg.range));
    const counts={}; arr.forEach(x=>counts[x]=(counts[x]||0)+1); const mode=Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
    const prompt=styleWrap(style, `Find the mode of [${arr.join(', ')}].`, {});
    const steps=[`Frequency count → mode=${mode}.`]; return { prompt, answer:Number(mode), steps };
  },
  rangeStat: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const n=rndInt(rng,5,12); const arr=Array.from({length:n},()=>rndInt(rng,1,cfg.range));
    const min=Math.min(...arr), max=Math.max(...arr); const prompt=styleWrap(style, `Find the range of [${arr.join(', ')}].`, {});
    const steps=[`Range=max-min=${max}-${min}=${max-min}.`]; return { prompt, answer:max-min, steps };
  },
  variance: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const n=rndInt(rng,4,8); const arr=Array.from({length:n},()=>rndInt(rng,1,cfg.range));
    const mean=arr.reduce((a,b)=>a+b,0)/n;
    const varPop = arr.reduce((s,x)=>s+(x-mean)*(x-mean),0)/n;
    const prompt=styleWrap(style, `Population variance of [${arr.join(', ')}]?`, {});
    const steps=[`σ²=Σ(x-μ)²/n=${varPop.toFixed(4)}.`]; return { prompt, answer:Number(varPop.toFixed(4)), steps };
  }
};
const StatisticsTemplates = [].concat(
  buildFamilyVariants(StatisticsFamilies.mean, 25),
  buildFamilyVariants(StatisticsFamilies.median, 25),
  buildFamilyVariants(StatisticsFamilies.mode, 20),
  buildFamilyVariants(StatisticsFamilies.rangeStat, 16),
  buildFamilyVariants(StatisticsFamilies.variance, 16)
); // 102

/* ---------- Number Theory ---------- */
const NumberTheoryFamilies = {
  gcdEuclid: (rng,d,style,v)=>{
    const a=rndInt(rng,20,300), b=rndInt(rng,20,300); const G=gcd(a,b);
    const prompt=styleWrap(style, `Find gcd(${a}, ${b}).`, {});
    const steps=[`Euclidean algorithm → ${G}.`]; return { prompt, answer:G, steps };
  },
  lcmFromGcd: (rng,d,style,v)=>{
    const a=rndInt(rng,4,60), b=rndInt(rng,4,60); const G=gcd(a,b), L=Math.abs(a*b)/G;
    const prompt=styleWrap(style, `Find lcm(${a}, ${b}).`, {});
    const steps=[`lcm=|ab|/gcd=${L}.`]; return { prompt, answer:L, steps };
  },
  primeCheck: (rng,d,style,v)=>{
    const n=rndInt(rng,10,400); const isPrime=(x)=>{ if(x<2) return false; for(let i=2;i*i<=x;i++) if(x%i===0) return false; return true; };
    const prompt=styleWrap(style, `Is ${n} prime? Answer 1 for prime, 0 for composite.`, {});
    const steps=[`Check divisors ≤√${n} → ${isPrime(n)?'prime':'composite'}.`]; return { prompt, answer: isPrime(n)?1:0, steps };
  },
  totientEasy: (rng,d,style,v)=>{
    const p=rndInt(rng,2,29); // not guaranteed prime; keep as template variety
    const prompt=styleWrap(style, `If p is prime, φ(p) = p − 1. For p=${p}, give φ(p).`, {});
    const steps=[`φ(p)=p-1 → ${p-1}.`]; return { prompt, answer:p-1, steps };
  },
  divisorCount: (rng,d,style,v)=>{
    const n=rndInt(rng,12,240); let cnt=0; for(let i=1;i*i<=n;i++){ if(n%i===0){ cnt+= (i*i===n?1:2); } }
    const prompt=styleWrap(style, `How many positive divisors does ${n} have?`, {});
    const steps=[`Count divisors via pairs → ${cnt}.`]; return { prompt, answer:cnt, steps };
  }
};
const NumberTheoryTemplates = [].concat(
  buildFamilyVariants(NumberTheoryFamilies.gcdEuclid, 25),
  buildFamilyVariants(NumberTheoryFamilies.lcmFromGcd, 25),
  buildFamilyVariants(NumberTheoryFamilies.primeCheck, 25),
  buildFamilyVariants(NumberTheoryFamilies.totientEasy, 15),
  buildFamilyVariants(NumberTheoryFamilies.divisorCount, 12)
); // 102

/* ---------- Sequences & Series ---------- */
const SeqFamilies = {
  arithmeticTerm: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const a1=rndInt(rng,1,cfg.range), r=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5)));
    const n=rndInt(rng,4,10+cfg.steps); const term=a1+(n-1)*r;
    const prompt=styleWrap(style, `Arithmetic seq a1=${a1}, r=${r}. Find a_${n}.`, {});
    const steps=[`a_n=a_1+(n-1)r=${term}.`]; return { prompt, answer:term, steps };
  },
  arithmeticSum: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const a1=rndInt(rng,1,cfg.range), r=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5)));
    const n=rndInt(rng,4,10+cfg.steps), an=a1+(n-1)*r, S=n*(a1+an)/2;
    const prompt=styleWrap(style, `Arithmetic seq a1=${a1}, r=${r}. Find S_${n}.`, {});
    const steps=[`S_n=n(a_1+a_n)/2=${S}.`]; return { prompt, answer:S, steps };
  },
  geometricTerm: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const a1=rndInt(rng,1,cfg.range), r=rndInt(rng,2,Math.max(3,Math.floor(cfg.range/5)));
    const n=rndInt(rng,3,8+cfg.steps), term=a1*Math.pow(r,n-1);
    const prompt=styleWrap(style, `Geometric seq a1=${a1}, r=${r}. Find a_${n}.`, {});
    const steps=[`a_n=a_1 r^{n-1}=${term}.`]; return { prompt, answer:term, steps };
  },
  geometricSum: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const a1=rndInt(rng,1,cfg.range), r=rndInt(rng,2,Math.max(3,Math.floor(cfg.range/5)));
    const n=rndInt(rng,3,8+cfg.steps), S=a1*(Math.pow(r,n)-1)/(r-1);
    const prompt=styleWrap(style, `Geometric seq a1=${a1}, r=${r}. Find S_${n}.`, {});
    const steps=[`S_n=a_1 (r^n-1)/(r-1)=${Number(S.toFixed(4))}.`]; return { prompt, answer:Number(S.toFixed(4)), steps };
  }
};
const SeqTemplates = [].concat(
  buildFamilyVariants(SeqFamilies.arithmeticTerm, 28),
  buildFamilyVariants(SeqFamilies.arithmeticSum, 24),
  buildFamilyVariants(SeqFamilies.geometricTerm, 26),
  buildFamilyVariants(SeqFamilies.geometricSum, 24)
); // 102

/* ---------- Functions ---------- */
const FunctionsFamilies = {
  linearEval: (rng,d,style,v)=>{
    const a=rndInt(rng,1,12), b=rndInt(rng,-20,20), x=rndInt(rng,1,20);
    const fx=a*x+b; const prompt=styleWrap(style, `Let f(x)=${a}x+${b}. Compute f(${x}).`, {});
    const steps=[`f(${x})=${a}×${x}+${b}=${fx}.`]; return { prompt, answer:fx, steps };
  },
  compositeEval: (rng,d,style,v)=>{
    const a=rndInt(rng,1,5), b=rndInt(rng,-10,10), c=rndInt(rng,1,5), d0=rndInt(rng,-10,10), x=rndInt(rng,1,10);
    const f=(t)=>a*t+b, g=(t)=>c*t+d0; const val=f(g(x));
    const prompt=styleWrap(style, `f(x)=${a}x+${b}, g(x)=${c}x+${d0}. Compute f(g(${x})).`, {});
    const steps=[`g(${x})=${c}×${x}+${d0}=${g(x)}; f(g(${x}))=${a}×${g(x)}+${b}=${val}.`]; return { prompt, answer:val, steps };
  },
  piecewiseEval: (rng,d,style,v)=>{
    const x=rndInt(rng,-10,10), a=rndInt(rng,1,5), b=rndInt(rng,-10,10);
    const prompt=styleWrap(style, `f(x)= { ax+b for x≥0; b−ax for x<0 } with a=${a}, b=${b}. Compute f(${x}).`, {});
    const fx = x>=0 ? a*x+b : b - a*x;
    const steps=[`Apply branch: f(${x})=${fx}.`]; return { prompt, answer:fx, steps };
  },
  inverseLinear: (rng,d,style,v)=>{
    const a=rndInt(rng,1,8), b=rndInt(rng,-12,12);
    const prompt=styleWrap(style, `f(x)=${a}x+${b}. Give f^{-1}(y) in the form (y - b)/a evaluated at y=${rndInt(rng,1,20)}.`, {});
    const y=rndInt(rng,1,20); const inv=(y-b)/a; const steps=[`f^{-1}(y)=(y-b)/a → ${(y-b)}/${a} = ${inv}.`]; return { prompt, answer:inv, steps };
  }
};
const FunctionsTemplates = [].concat(
  buildFamilyVariants(FunctionsFamilies.linearEval, 30),
  buildFamilyVariants(FunctionsFamilies.compositeEval, 24),
  buildFamilyVariants(FunctionsFamilies.piecewiseEval, 24),
  buildFamilyVariants(FunctionsFamilies.inverseLinear, 24)
); // 102

/* ---------- Linear Equations ---------- */
const LinearEqFamilies = {
  solveAxB: (rng,d,style,v)=>{
    const cfg=diffConf[d]; const A=rndInt(rng,1,cfg.range), B=rndInt(rng,-cfg.range,cfg.range), C=rndInt(rng,-cfg.range,cfg.range);
    const x=(C-B)/A; const prompt=styleWrap(style, `Solve ${A}x + ${B} = ${C} for x.`, {});
    const steps=[`x=(${C}-${B})/${A}=${x}.`]; return { prompt, answer:x, steps };
  },
  slopeIntercept: (rng,d,style,v)=>{
    const m=rndInt(rng,-10,10), c=rndInt(rng,-10,10), x=rndInt(rng,1,10);
    const y=m*x+c; const prompt=styleWrap(style, `Line y=${m}x+${c}. Find y when x=${x}.`, {});
    const steps=[`y=${m}×${x}+${c}=${y}.`]; return { prompt, answer:y, steps };
  },
  pointSlope: (rng,d,style,v)=>{
    const m=rndInt(rng,-5,5)||1, x1=rndInt(rng,-10,10), y1=rndInt(rng,-10,10), x=rndInt(rng,-10,10);
    const y = y1 + m*(x - x1);
    const prompt=styleWrap(style, `Line through (${x1},${y1}) slope ${m}. Find y at x=${x}.`, {});
    const steps=[`y=y1+m(x-x1)=${y1}+${m}(${x}-${x1})=${y}.`]; return { prompt, answer:y, steps };
  },
  intercepts: (rng,d,style,v)=>{
    const m=rndInt(rng,1,10), c=rndInt(rng,-20,20);
    const xInt = -c/m; const prompt=styleWrap(style, `For y=${m}x+${c}, give the x-intercept.`, {});
    const steps=[`x-int: set y=0 → x=-c/m=${-c}/${m}=${xInt}.`]; return { prompt, answer:xInt, steps };
  }
};
const LinearEqTemplates = [].concat(
  buildFamilyVariants(LinearEqFamilies.solveAxB, 30),
  buildFamilyVariants(LinearEqFamilies.slopeIntercept, 24),
  buildFamilyVariants(LinearEqFamilies.pointSlope, 24),
  buildFamilyVariants(LinearEqFamilies.intercepts, 24)
); // 102

/* ---------- Systems of Equations ---------- */
const SystemsFamilies = {
  solve2x2Cramer: (rng,d,style,v)=>{
    const cfg=diffConf[d];
    const a1=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5))), b1=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5))), c1=rndInt(rng,-cfg.range,cfg.range);
    const a2=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5))), b2=rndInt(rng,1,Math.max(2,Math.floor(cfg.range/5))), c2=rndInt(rng,-cfg.range,cfg.range);
    let det=a1*b2 - a2*b1; if(det===0) det+=1;
    const x=(c1*b2 - c2*b1)/det, y=(a1*c2 - a2*c1)/det;
    const prompt=styleWrap(style, `Solve: ${a1}x+${b1}y=${c1}, ${a2}x+${b2}y=${c2}. Provide x.`, {});
    const steps=[`Δ=${det}; x=(c1b2-c2b1)/Δ=${x}.`]; return { prompt, answer:x, steps };
  },
  eliminationToY: (rng,d,style,v)=>{
    const a1=rndInt(rng,1,6), b1=rndInt(rng,1,6), c1=rndInt(rng,-20,20);
    const a2=rndInt(rng,1,6), b2=rndInt(rng,1,6), c2=rndInt(rng,-20,20);
    let det=a1*b2 - a2*b1; if(det===0) det+=1;
    const y=(a1*c2 - a2*c1)/det;
    const prompt=styleWrap(style, `Solve the system for y: ${a1}x+${b1}y=${c1}; ${a2}x+${b2}y=${c2}.`, {});
    const steps=[`Eliminate x; y=${y}.`]; return { prompt, answer:y, steps };
  },
  classifySystem: (rng,d,style,v)=>{
    const a1=rndInt(rng,1,6), b1=rndInt(rng,1,6), c1=rndInt(rng,-12,12);
    const k=rndInt(rng,2,9);
    const a2=a1*k, b2=b1*k, c2=rndInt(rng,-12,12);
    const consistent = (c2 === c1*k);
    const prompt=styleWrap(style, `Classify: ${a1}x+${b1}y=${c1}; ${a2}x+${b2}y=${c2}. 1=unique, 0=none, 2=infinitely many.`, {});
    const ans = consistent ? 2 : 0; const steps=[`Coefficients proportional; constants ${consistent?'also':'not'} proportional.`];
    return { prompt, answer:ans, steps };
  }
};
const SystemsTemplates = [].concat(
  buildFamilyVariants(SystemsFamilies.solve2x2Cramer, 40),
  buildFamilyVariants(SystemsFamilies.eliminationToY, 32),
  buildFamilyVariants(SystemsFamilies.classifySystem, 32)
); // 104

/* ---------- Exponents & Radicals ---------- */
const ExpRadFamilies = {
  powers: (rng,d,style,v)=>{
    const base=rndInt(rng,2,12), exp=rndInt(rng,2,8);
    const prompt=styleWrap(style, `Compute ${base}^${exp}.`, {});
    const steps=[`${base}^${exp}=${Math.pow(base,exp)}.`]; return { prompt, answer:Math.pow(base,exp), steps };
  },
  productRule: (rng,d,style,v)=>{
    const a=rndInt(rng,2,6), m=rndInt(rng,1,5), n=rndInt(rng,1,5);
    const prompt=styleWrap(style, `Simplify ${a}^${m} · ${a}^${n}. Give exponent.`, {});
    const steps=[`m+n=${m+n}.`]; return { prompt, answer:m+n, steps };
  },
  quotientRule: (rng,d,style,v)=>{
    const m=rndInt(rng,2,8), n=rndInt(rng,1,m-1);
    const prompt=styleWrap(style, `Simplify x^${m} / x^${n}. Give exponent.`, {});
    const steps=[`m-n=${m-n}.`]; return { prompt, answer:m-n, steps };
  },
  powerOfPower: (rng,d,style,v)=>{
    const m=rndInt(rng,2,6), n=rndInt(rng,2,6);
    const prompt=styleWrap(style, `Simplify (x^${m})^${n}. Give exponent.`, {});
    const steps=[`m·n=${m*n}.`]; return { prompt, answer:m*n, steps };
  },
  simplifyRoot: (rng,d,style,v)=>{
    const k=rndInt(rng,2,12), m=rndInt(rng,2,12); const x=k*k*m;
    const prompt=styleWrap(style, `Simplify √${x}. Give the coefficient outside the radical.`, {});
    const steps=[`√(${k*k}·m)=${k}√m → coefficient ${k}.`]; return { prompt, answer:k, steps };
  }
};
const ExpRadTemplates = [].concat(
  buildFamilyVariants(ExpRadFamilies.powers, 28),
  buildFamilyVariants(ExpRadFamilies.productRule, 24),
  buildFamilyVariants(ExpRadFamilies.quotientRule, 24),
  buildFamilyVariants(ExpRadFamilies.powerOfPower, 24),
  buildFamilyVariants(ExpRadFamilies.simplifyRoot, 8)
); // 108

/* ===== Branch map to templates ===== */
const TemplateBank = {
  'Arithmetic': ArithmeticTemplates,
  'Algebra': AlgebraTemplates,
  'Ratios & Proportions': RatioTemplates,
  'Rates': RatesTemplates,
  'Percentages': PercentTemplates,
  'Geometry': GeometryTemplates,
  'Probability': ProbabilityTemplates,
  'Statistics': StatisticsTemplates,
  'Number Theory': NumberTheoryTemplates,
  'Sequences & Series': SeqTemplates,
  'Functions': FunctionsTemplates,
  'Linear Equations': LinearEqTemplates,
  'Systems of Equations': SystemsTemplates,
  'Exponents & Radicals': ExpRadTemplates
};

/* ===== Combination estimator ===== */
function estimateCombinations() {
  const stylesCount = styles.length, diffCount = difficulties.length;
  let totalTemplates = 0;
  for (const b of branches) totalTemplates += TemplateBank[b].length;
  const paramMultiplier = 40; // conservative parameter variety
  return totalTemplates * stylesCount * diffCount * paramMultiplier;
}

/* ===== UI & interactions ===== */
function setSeed(str){
  const s=str&&str.trim()? str.trim() : `MATH-${Date.now()}-${Math.floor(Math.random()*1e6)}`;
  state.seed=s; state.rng=makeRNG(hashSeed(s));
  document.getElementById('seedDisplay').textContent=s; document.getElementById('seed').value=s;
}
function bootFromURL(){
  const q=new URLSearchParams(location.search);
  const branch=q.get('branch'), difficulty=q.get('difficulty'), style=q.get('style'), seed=q.get('seed');
  // populate branch select
  const sel=document.getElementById('branch'); branches.forEach(b=>{ const opt=document.createElement('option'); opt.textContent=b; sel.appendChild(opt); });
  if(branch && branches.includes(branch)) sel.value=branch; else sel.value=branches[0];
  if(difficulty && difficulties.includes(difficulty)) document.getElementById('difficulty').value=difficulty;
  if(style && styles.includes(style)) document.getElementById('style').value=style;
  setSeed(seed||null);
}
function readControls(){
  state.branch=document.getElementById('branch').value;
  state.difficulty=document.getElementById('difficulty').value;
  state.style=document.getElementById('style').value;
  const sd=document.getElementById('seed').value.trim(); if(sd) setSeed(sd); else if(!state.seed) setSeed(null);
}
function generateProblem(){
  readControls();
  const templates=TemplateBank[state.branch];
  // pick template deterministically with RNG
  const idx=rndInt(state.rng, 0, templates.length-1);
  const gen=templates[idx];
  const out=gen(state.rng, state.difficulty, state.style);
  state.current=out;
  document.getElementById('meta').textContent = `${state.branch} • ${state.difficulty.toUpperCase()} • ${state.style} • Template #${idx+1}/${templates.length}`;
  document.getElementById('problem').textContent = out.prompt;
  document.getElementById('solution').style.display='none';
  document.getElementById('solution').textContent=out.steps.join('\n');
  document.getElementById('feedback').textContent='';
  document.getElementById('answer').value='';
}
function checkAnswer(){
  const user=parseAnswer(document.getElementById('answer').value);
  if(user===null){ document.getElementById('feedback').textContent='Enter a valid number/fraction/percent.'; return; }
  const ans=state.current?.answer;
  let ok;
  if(typeof ans==='number'){
    if(Number.isInteger(ans)) ok=(user===ans);
    else ok=approxEqual(user,ans,1e-4);
  } else {
    // fallback strict equality for non-numeric cases
    ok = String(user).trim()===String(ans).trim();
  }
  document.getElementById('feedback').innerHTML = ok ? '<span class="ok">Correct!</span>' : '<span class="no">Not quite.</span>';
}
function randomizeOptions(){
  const rng=state.rng||makeRNG(hashSeed(String(Date.now())));
  const sel=document.getElementById('branch'); sel.value=choice(rng,branches);
  document.getElementById('difficulty').value=choice(rng,difficulties);
  document.getElementById('style').value=choice(rng,styles);
}
function showSolution(){ document.getElementById('solution').style.display='block'; }
function newProblemSameSettings(){ setSeed(state.seed+'-'+Math.floor(Math.random()*100000)); generateProblem(); }
function copyLink(){
  const params=new URLSearchParams({ branch:state.branch, difficulty:state.difficulty, style:state.style, seed:state.seed });
  const url=`${location.origin}${location.pathname}?${params.toString()}`;
  navigator.clipboard.writeText(url).then(()=>{ document.getElementById('feedback').textContent='Link copied.'; });
}

/* ===== Init ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  bootFromURL();
  const combos=estimateCombinations();
  document.getElementById('comboCount').textContent = `Estimated unique combinations: ${combos.toLocaleString()}+`;
  // branch template counts
  const lines = branches.map(b=>`${b}: ${TemplateBank[b].length} templates`).join(' • ');
  document.getElementById('branchCounts').textContent = lines;

  document.getElementById('generate').addEventListener('click', generateProblem);
  document.getElementById('check').addEventListener('click', checkAnswer);
  document.getElementById('randomize').addEventListener('click', ()=>{ randomizeOptions(); generateProblem(); });
  document.getElementById('showSolution').addEventListener('click', showSolution);
  document.getElementById('newProblem').addEventListener('click', newProblemSameSettings);
  document.getElementById('copyLink').addEventListener('click', copyLink);
  document.getElementById('newSeed').addEventListener('click', ()=>{ setSeed(null); });
});
</script>
</body>
</html>
